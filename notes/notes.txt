Переменные:
    char c = '1';    // символ
    bool b = true;   // логическая переменная, принимает значения false и true
    int i = 42;      // целое число (занимает, как правило, 4 байта)
    short int i = 17;            // короткое целое (занимает 2 байта)
    long li = 12321321312;       // длинное целое (как правило, 8 байт)
    long long lli = 12321321312; // длинное целое (как правило, 8 байт)
    float f = 2.71828;           // дробное число с плавающей запятой (4 байта)
    double d = 3.141592;         // дробное число двойной точности (8 байт)
    long double ld = 1e15;       // длинное дробное (как правило, 16 байт)

Escape-sequences:
    \a	    Alarm or Beep	It is used to generate a bell sound in the C program.
    \b	    Backspace	    Она используется для перемещения курсора на одно место назад.
    \f	    Form Feed	    Используется для перемещения курсора в начало следующей логической страницы.
    \n	    New Line	    It moves the cursor to the start of the next line.
    \r	    Carriage Return	It moves the cursor to the start of the current line.
    \t	    Horizontal Tab	It inserts some whitespace to the left of the cursor and moves the cursor accordingly.
    \v	    Vertical Tab	It is used to insert vertical space.
    \\	    Backlash	    Используется для вставки символа обратной косой черты.
    \’	    Single Quote	It is used to display a single quotation mark.
    \”	    Double Quote	It is used to display double quotation marks.
    \?	    Question Mark	It is used to display a question mark.
    \ooo	Oct. Number	    It is used to represent an octal number.
    \xhh	Hex. Number	    It represents the hexadecimal number.
    \0	    NULL	        It represents the NULL character.

Русский язык в терминале
    В начале функции main() вставить 
        setlocale(LC_ALL, "Russian");
    чтобы в терминале не было проблем с русским языком

Очистка памяти
    В конце main() вставить
        return 0;
    чтобы очистить память после работы проги

Указатели и ссылки
    Ссылка - псевдоним переменной, а указатель - адрес переменной в памяти

    Объявляем:    тип_указателя* имя_указателя;  - можно так, а можно дать значение сразу
                  тип_ссылки& имя_ссылки;  - ошибка!! (надо сразу назначить значение)
                  тип ссылки& имя_ссылки = имя переменной; - правильно

    Придаем значение:    имя_указателя = &имя_переменной

    Значение:   &имя_переменной == адрес переменной
                имя_переменной == значение переменной
                имя_указателя == адрес переменной
                *имя_указателя == значение переменной
                &*имя_указателя == адрес указателя
                имя_ссылки == значение переменной
                &имя_ссылки == адрес переменной

Вложенные функциями по адресу               
    передача ф1 в ф2 (simpe wout typedef)

        1. пусть ф1 будет задана так:
            тип_ф1 имя_ф1(тип_значения_ф1 имя_значения_ф1){
                тело ф1
            }
        
        3. Объявляем указатель:
            тип_ф1 (*p)(тип_значения_ф1) = NULL;

        4. Инициализируем указатель:
            p = &имя_ф1

        2. передадим ф1 в ф2:
            тип_ф2 имя_ф2 (тип_ф1 (*p)(тип_значения_ф1)) {
                четотам = (*p)(значение_для_ф1);
            }

    передача функции в функцию (w typedef) - для нескольких ссылок на однородные функции

        1. Создадим темплейт для указателя на передаваемую функцию:
            typedef тип_ф1 (*имя_темплейта)(тип_значения_ф1);

        2. Создадим функцию ф1:
            тип_ф1 имя_ф1 (тип_значения_ф1){
                тело ф1
            }
        
        3. Создадим указатель на ф1:
            имя_темплейта имя_указателя = &имя_ф1;

        4. передадим в ф2 <- ф1:
            тип_ф2 имя_ф2 (тип_значения_ф1 имя_значения_ф2) {
                имя_указателя(имя_значения_ф2);
            }

    предыдущий пункт 2 часть
        пусть есть функция double func1(double);

        тогда создаем typedef double (*TDF)(double)
            создаем void func2 (TDF lalala);

        теперь если вызвать func2 со значением (func1), мы вызовем функ1 в функ2 по адрессу!!!

    примеры
        #include <iostream>
        using namespace std;

        void f1(double &a){
            a += 5;
            return;
        }

        void (*ssylka)(double&) = &f1;      //ссылка на функцю 1

        void f2(double &a){                 //тут в функции используется ссылка на функцию
            ssylka(a);                      //без объявления в поступаемых значениях
            return;
        }

        typedef void (*TDF)(double&);       //создаем темплейт для обьявления ссылок

        void f3(TDF b, double& a){          //тут передаем ссылку используя темплейт TDF
            b(a);                           
            return;
        }

        void f4(void(*b)(double&), double&a){       // тут передаем ссылку без вспомогательных средств
            b(a);
            return;
        }

        int main(){
            double k = 1.0;
            f1(k);
            f2(k);
            f3(f1, k);
            f4(f1, k);
            cout << k;
        }

Рандомайзер
    #include <time.h>						                //time
    #include <stdlib.h> 					                //srand, rand
    #include <iostream>
    #include "Randomizer.h"                                 //для объявления в хедере

    using namespace std;

    int iRandom(int a, int b){				                // целое из [a, b] 
        return rand()%(b-a+1) + a;
    }

    double dRandom(int a, int b){			                // вещественное из [a, b]
        return a + (b - a) * rand() / (double)RAND_MAX;
    }

    void Randomize() {						                
        srand((unsigned int)time(NULL));                    //	начальное число - время
        rand();                                             //  сброс первого числа, чтобы не повторялось,
    }                                                       //  пока srand не изменится

Массив в структуре и структура в массиве
    1.Массив в структуре

        Struct имя_структуры{
            int first;
            char second[20];
        }

        имя_структуры имя_переменной {212, "example"}

        cout << имя_переменной.second[1];   // выведет 'е'

    2.Структура в массиве

        Struct имя_структуры{
            int first;
            char second;
        }

        имя_структуры имя_переменной[3] {
            {12, 'k'},
            {13412, 'u'},
            {1232, 't'},
        }

        cout << имя_переменной[2].second;   // выведет 'u'

new & delete
    new
        в функции под переменные не выделяется память, следовательно, для того чтобы
        после функции можно было использовать переменную используется new:
            тип* имя_указателя = new тип_переменной имя_переменной
        
        Чтобы задать двумерный динамический массив надо:
            double** mass = new double* mass[n]
            for(int i = 0; i < n; ++i){
                mass[n] = new double[m];
            }

    delete
        чтобы удалить объект,созданный с помощью new из памяни, воспользуемся delete:
        
        delete имя_указателя; //для удаления одного объекта
        delete[] имя_указателя; //для удаления динамического массива

с-строка
    Можно задать c-строку через ссылку и через массив:
        char* a = "пепсикольный"
        char a[] = "пепсикольный"
    Тогда у значения в первом случае не будет имени, а только ссылка

sizeof() | strlen()
    sizeof() - возвращает длину массива
    strlen() - возвращает сколько значений в массиве заполнено до '\0' (не включительно)      // #include <string.h>
     
Работа с файлами
    первым делом надо открыть файл:
        Сразу:
            ifstream (const char* filename, ios_base::openmode mode = ios_base::in); 
            ifstream fin(filename, openmode) by default openmode = ios::in 
            ifstream fin(“filename”);

            * чтобы не читать из файла, а записывать - все так-же с ofstream

        После объявления, методом open:
            ifstream fin;
            fin.open(filename, openmode) 
            fin.open(“filename”); 

        Openmodes:
            std::ios::in - открыть файл для чтения - стандарт в ifstream
            std::ios::out - открыть файл для записи - стандарт в ofstream
            std::ios::binary - открытие файла в двоичном режиме
            std::ios::ate - при открытии переместить указатель в конец файла
            std::ios::app - открыть файл для записи в конец файла
            std::ios::trunc - удалить содержимое файла, если он существует

            Чтобы сразу несколько модов выбрать, пишем их так:  mod1 | mod2

    fout | fin
        filename << "текст" (или циклом for из массива) - запись в файл (fout - ofstream)
        filename >> переменная - запись буквы из файла в переменную
            с переносом курсора вправо на 1 (fin - ifstream)
    
    чтобы узнать на каком месте стоит курсур:
        size_t FileSize = file.tellg()
    
    чтобы перенести текст из ofstream в массив символов циклом for:
        for (int i = 0; i < количество_символов_в_файле; i++){
            имя_ofstream.get(имя_массива[i]);
        }

    не забудь закрыть файл в конце работы с ним:
        file.close();

Передача данных в массив с клавиатуры методами << | cin.getline()
    cin.getline(куда, сколько символов максимум);                   //ввод строки до нажатия enter
    cin >> имя_строки;                                              //ввод слова до пробела

Передача аргументов в main
    int main(int argc, char** argv)
    argc - количество переданных аргументов (изначально = 1, - название программы)
    argv - массив с переданными значениями (нулевой аргумент = название программы .exe)

    g++ ./filename.cpp && ./a.out   -   запуск через консоль